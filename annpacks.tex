%%
%% George Makrydakis irrequietus@gmail.com>
%% Copyright (C) 2014, All Rights Reserved
%%
%% This is my first C++ proposal

\documentclass[ notitlepage
              , a4paper
              , twoside ]{article}

\usepackage{fontspec}
\usepackage[T1]{fontenc}
\usepackage{charter}
\usepackage[expert]{mathdesign}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{polyglossia}
\usepackage{xunicode}
\usepackage{xltxtra}
\usepackage{csquotes}
\usepackage{tabularx}

\usepackage[ usenames
           , dvipsnames ]{xcolor}

\usepackage[ outer=3.4cm
           , heightrounded
           , marginparwidth=6cm
           , marginparsep=0.5cm ]{geometry}

\usepackage[pdfauthor={George Makrydakis},
            pdftitle={Annotating C++ template parameter packs},
            pdfsubject={},
            pdfkeywords={ C++
                        , templates
                        , meta-programming
                        , template parameters
                        , template parameter packs
                        , pattern generation },
            pdfproducer={XeLateX with hyperref},
            unicode=true,
            pdfencoding=auto,
            pdfcreator={Xelatex}]{hyperref}

\usepackage{newtxtext}
\usepackage{newtxmath}
\usepackage{upgreek}
\usepackage{bookmark}
\usepackage{bm}
\usepackage{listings}
\usepackage{color}
\usepackage{tikz}
\usepackage{minted}
\usepackage{tcolorbox}
\usepackage{etoolbox}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{textcomp}
\usepackage{mparhack}
\usepackage{draftwatermark}
\usepackage{relsize}
\usepackage[nottoc,numbib]{tocbibind}
\usepackage[nodate]{datetime}
\usepackage{everypage} %%% solving page layout problems in different pages
\usepackage[backend=biber,sorting=nyt,natbib
           , doi=false]{biblatex}

%%% getting git revision information
\input{gitrev.tex}

%%% clearing month, day
\AtEveryBibitem{\clearfield{month}}
\AtEveryBibitem{\clearfield{day}}
%%% nobreakspace fix           
\DeclareTextCommandDefault{\nobreakspace}{\leavevmode\nobreak\ } 
            
%%% defining some colors I like using
\definecolor{tone0}{RGB}{190,58,238}
\definecolor{tone1}{RGB}{1,41,110}
\definecolor{tone3}{HTML}{002B36}

%%% the main language of this document is of course english.
\setmainlanguage{english}

%%% setting page style
\pagestyle{fancyplain}

%%% paragraph formatting
\setlength{\parskip}{0.2cm plus1mm minus1mm}
\setlength{\abovedisplayskip}{12pt}
\setlength{\abovedisplayshortskip}{12pt}
\setlength{\belowdisplayskip}{12pt}
\setlength{\belowdisplayshortskip}{12pt}

%%% settings for hyperlinks
\hypersetup{ unicode=true
           , colorlinks=true
           , linkcolor=Blue
           , citecolor=MidnightBlue
           , filecolor=magenta
           , urlcolor=magenta }

%%% activating everypage hooks for header geometry issues
\AddEverypageHook{%
    \ifthenelse{\value{page}=1}%
    {\renewcommand{\headheight}{72pt}}
    {\renewcommand{\headrulewidth}{0.0pt}}%
    {\renewcommand{\headrulewidth}{0.4pt}}%
}

%%% making 'minted' segments embedded into a colorbox           
\AtBeginEnvironment{minted}{\fontsize{8}{8}\selectfont}
    \BeforeBeginEnvironment{minted}{\begin{tcolorbox}}
\AfterEndEnvironment{minted}{\end{tcolorbox}}

\usemintedstyle{trac}

%%% A macro for referring to non-type, type, template template parameter types.
\newcommand{\typepack}[1]{$\bm{\uptau_{#1}$}}
\newcommand{\epack}[1]{$\overset{...}{#1}$}

%%% macros for numbering paragraphs, essentially the \p{} macro
\newcommand{\parnum}{\bfseries\arabic{parcount}}
\newcounter{parcount}
\newcommand\p{%
    \stepcounter{parcount}%
    \leavevmode\marginpar[\hfill\parnum]{\parnum}%
}

%%% cleanup all information related to fancy headers
\fancyhf{}

%%% set footer information
\fancyfoot[LO,RE]{\thepage{}\
\center{Copyright \textcopyright{2014} George Makrydakis\\
\texttt{\href{mailto:irrequietus@gmail.com}{irrequietus@gmail.com}}}}

%%% set header information. The first page header is slightly different
\fancyhead[LE,RO]{\ifthenelse{\value{page}=1}{{\begin{tabular}{r l}\
{\color{magenta}docnum} &  {\color{tone0} DEEMED IMMATURE} \\
{\color{magenta}project} & Programming Language C++, EWG \\
{\color{magenta}date} & \date{\today{} \currenttime{} EEST} \\
{\color{magenta}author} & George Makrydakis \\
{\color{magenta}reply-to} & \texttt{\href{mailto:irrequietus@gmail.com}{irrequietus@gmail.com}} \\
\end{tabular}}}{\slshape Annotating C++ template parameter packs\\
\bf{{\color{magenta} \GitLongRev{} - \date{\today{} \currenttime{} EEST}}}}}
    
%%% setting the width of the header ruler
\renewcommand{\headrulewidth}{0.2pt}
    
%%% watermark info for the draft stage
\SetWatermarkLightness{0.942}
\SetWatermarkScale{3}


\setlength{\headheight}{30pt}

%%% I do not want the language string present in each bibliography item.
\renewbibmacro{in:}{}%
\AtEveryBibitem{%
  \clearlist{language}%
}

\addbibresource{annpacks.bib}



\begin{document}

\bookmark[dest=TitlePage]{Annotating C++ template parameter packs}

\title{Annotating C++ template parameter packs}
\author{George Makrydakis\\
\texttt{\href{mailto:irrequietus@gmail.com}{irrequietus@gmail.com}}\\\bf{{\
\color{magenta}UNCORRECTED INCOMPLETE DRAFT
\date{\bf{\today{} \currenttime{} EEST}}}}}
\maketitle


\begin{abstract}
\p Parametric polymorphism in C++\cite{cpp11} is implemented through class and function templates whose parameter types refer to three different abstractions used for template declarations: template non-type, template type and template-template type parameters.
Since C++11, a fourth kind of template parameter abstraction known as the template parameter pack has been introduced, expressing an ordered sequence of a variable number of parameter types, the exact specifics of which to be decided during instantiation.

\p In their current incarnation, template parameter packs do not have any notation explicitely descriptive of their size and/or actual expansion intent.
Resourceful combinations of parameter packs with partial specializations, SFINAE, ADL and partial ordering are extensively deployed in several template programming and meta-programming techniques for code generation purposes.

\p This proposal argues that \textit{optionally annotating C++ template parameter packs} in a backwards compatible manner with information about size, repetition and patterned expansion during their use in template parameter lists can be detrimental in reducing the cost of using templates as computational constructs within a given translation unit.
As a result, code generation techniques based on simple template programming and meta-programming would require less source code boilerplate containing templates or relying to type-unsafe C++ preprocessor meta-programming to be required.
\end{abstract}

\section{Introduction}
\p Template parameter packs can be viewed as product types from a type-theoretical point of view, with cohere but undecided boundary semantics in both their declaration and expansion within a given template parameter list, until the template containing them is a valid instantiative match.

\p Pattern matching driven approaches through class template partial specializations and function template template parameter lists in combination with features like SFINAE, have proven their worth in the meta-programming armamentary of widely used and critically acclaimed C++ libraries like Boost.
Such libraries make extensive use of compile-time computational constructs for code generation, with their C++03 emulation of parameter variadics through preprocessor meta-programming techniques eventually having lead to the introduction of variadic templates through parameter packs in C++11.

\p Packs led to concise, readable and error-free implementation of template meta-programming idioms through lowering the cost for pattern matching over lists of parameter types.
Template meta-programming idioms became extremely less dependent on SFINAE and horizontal pattern repetition through type-unsafe preprocessor meta-programming techniques requiring a lot more source code boilerplate.
However, packs have been unable to reduce the required boilerplate for useful type-level pattern matching over a wide sequence of common, repetitive patterns and/or of specified but numerous sequences of parameter types that are often used as pattern matching "values".
\section{Motivation and Scope}
\p \textit{{\color{tone1}There should be a few paragraphs here taking text from the old version.}}

\subsection{Using patterns as input for pattern matching}
\p \textit{{\color{tone1}There should be a few paragraphs here taking text from the old version.}}

\subsection{An attempt at formulating the problem}
\p For the purposes of conceptualization, we are going to borrow and admittedly abuse some of the mathematical notation available for formulations to which we will mix $\mathlarger{\bm{\{\}[]}}$ as "annotator" symbols for template parameter packs.
These two annotators will be providing unambiguous intent when translating to C++ code that is considered to be valid in the context of this proposal.
A C++ template parameter pack $...T$ will be symbolized as a capital letter with an overline (i.e. $\overline{T}$), while the $\bm{sizeof...(T)}$ constant expression will be symbolized as $|\overline{T}|$.
\p Unless otherwise specified, all other notation used in the following formulation refers to its pristine mathematical meaning.
At the current stage of this incomplete draft, there may be unintentional discrepancies that have to be corrected and will be in a newer version of this draft.
\subsubsection{The rules of pack annotation}
\begin{enumerate}
\item\p When $\mathlarger{\bm{\{N\}}}$ or $\mathlarger{\bm{\{N,K\}}}$ or $\mathlarger{\bm{\{\}}}$ are used, they are referring to constant expressions $N$ and $K$ used in the context of the \textit{interval annotator}.
The first case specifies that the given pack is actually a shorthand for a parameter sequence consisting of exactly $N$ parameters of the same kind (non-type,type-type,template-type).
When two comma-separated constant expressions are used, the \textit{interval annotator} refers to the a valid right-open interval of $[N,K)\in\mathbb{Z}_{\geq 1}$ within which the size of a pack matching the expression should be in order for the match to be valid.
When no expressions are used as in the last case, the intent for a pack $\overline{T}$ is equivalent to $\mathlarger{\bm{\{|\overline{T}|\}}}$ and $\mathlarger{\bm{\{0,|\overline{T}|\}}}$ which are \textit{interval annotation} for a parameter pack of zero or more parameters of the same kind (non-type,type-type,template-type).
\item\p When $\mathlarger{\bm{[]}}$ or $\mathlarger{\bm{[]}}$ or $\mathlarger{\bm{[N]}}$ are used, the \textit{pattern annotator} specifies that said annotated pack is made out of either 1 (i.e. $[]$ or $[1]$) or more ($[N]$) repetitions of the same sequence of types.
The size of the pack does not get altered by the \textit{pattern annotator} but in order for such an annotated pack to be a valid match, its size must be an exact multiple of the constant expression in the \textit{pattern annotator}.
\item\p An annotated template parameter pack is an n-ordered sequence of zero or more template parameters of the same type (non-type, type-type, template-type) whose identifier is followed by the \textit{interval} and \textit{pattern} annotators.
The \textit{interval annotator} must always precede the \textit{pattern annotator} while both follow the identifier used for the \textit{annotated template parameter pack}.
\item\p When the \textit{interval} annotator is used with a single constant expression, it can be referred to as \textit{anchoring annotator} and the annotation itself referred to as \textit{anchoring annotation} regardless of whether a \textit{pattern annotator} follows or not.
\item\p Annotated parameter packs that are coexisting with non-annotated parameter packs gain precedence in partial ordering over the latter unless they are equivalent forms, in which case a match cannot be made.
When \textit{anchoring annotation} is present, annotated parameter packs submit to the same matching rules as their equivalent parameter lists where parameters of the same kind (non-type, type-type, template-type) are specified in a non-pack form in the declaration of their template parameter list.
\item\p The use of \textit{full interval annotation} is permitted only in class templates since for each pack having \textit{full interval annotation}, a set of parameter lists whose rank equals the rank of the annotation interval is intended to be used, in the form of either class template partial specializations or nested class and function templates within the definition body whose template parameter list contains the \textit{full-interval} annotated pack.
\item\p When the \textit{pattern annotator} is used in the context of a template argument list, it resolves to expanding the preceding pack as many times as the \textit{pattern factor} dictates.
\item\p When \textit{full interval annotation} is used in the declaration of a template parameter list for a given pack, that pack can must be expanded using \textit{anchoring annotation}.
\item\p When \textit{anchoring annotation} has been used upon a pack, each parameter may be accessed individually at a given position by using the pack identifier followed by \textit{anchoring annotation} of a constant expression indicating that position.
This way of access cannot modify any parameter type present at a given position nor can it be used with non-annotated packs.
\end{enumerate}
\subsubsection{Understanding annotation equivalence}
\p First, a parameter pack is an n-ordered sequence (n-tuple) of zero or more parameter types of the same kind (non-type, type-type, template-type).
They can be viewed as product types and modelled using nested ordered pairs, in a way reminiscent of a left/right fold of a cons function over the n-tuple that they actually are.
The following two equivalent formulations inductively define a template parameter pack of $t_{0},t_{1},t_{2},...t_{n-1}$ are known to be valid representational approaches.
The most basic annotator equivalence is added to both.
\begin{align}
\overline{X}
    &\equiv \overline{X}\{\}[] = \underbrace{( t_{0}
                   , ( t_{1}
                     , (t_{2}
                     , ( \dots{}
                      , ( t_{n-1},\emptyset)\dots))))}_{n=|\overline{X}|=sizeof...(X)}\\
\overline{Y}
    &\equiv \overline{Y}\{\}[] = \underbrace{((\dots{} (((\emptyset{},t_{0})
                   ,  t_{1})
                     , t_{2})
                     ,  \dots{}
                      ), t_{n-1})}_{n=|\overline{Y}|=sizeof...(Y)}
\end{align}
\p We will be using the $\overline{X}$ formulation from now on, with an \textit{annotator} next to parameter pack declaration containing the size of the pack enclosed in curly braces as $\bm{\{j\}}$, when the intention is to force the j-tuple of contained elements that the pack is into a finite and well defined equivalent of the non-variadic form of said pack, which would be preferentially matched over the variadic form should the two coexist.
When either $\overline{T}\{sizeof...(T)\}$ or $\overline{T}\{|\overline{T}|\}$ are used, these are completely equivalent to declaring $\overline{T}\{\}$ and $\overline{T}$ and therefore the "size" annotation may be ommited.

\p Another important operation can also be modelled after valid C++11/C++14 code like the following (\textit{wrapper} and \textit{error\_type} were defined previously) when it comes to the semantics of joining two parameter packs of the same kind:
\begin{minted}{c++}
/* NOTE: valid C++11,C++14 code */
template<typename,typename>
struct join_packs
{ typedef error_type type; };

template<typename... A0, typename... A1>
struct join_packs<wrapper<A0...>,wrapper<A1...>>
{ typedef wrapper<A0...,A1...> type; };
\end{minted}
This will be formulated through the following convention that can be generalized for an arbitrary amount of parameter packs, having any variation of size and ordered sequence of types abstracted in said packs:
\begin{align}
\langle\overline{A_{0}}\{j_{0}\}\rangle &= (\overline{A_{0}}\{j_{0}\},\emptyset{}) =\nonumber\\
&=(a_{0_{0}},(a_{0_{1}},(a_{0_{2}},...(a_{0_{j_{0}-1}},\emptyset{})\dots{})))\\
\langle\overline{A_{0}}\{j_{0}\},\overline{A_{1}}\{j_{1}\}\rangle &= (\overline{A_{0}}\{j_{0}\},(\overline{A_{1}}\{j_{1}\},\emptyset{}))=\nonumber\\
&=(a_{0_{0}},(a_{0_{1}},(a_{0_{2}},...(a_{0_{j_{0}-1}},\overline{A_{1}}\{j_{1}\})\dots{})))\\
&=(a_{0_{0}},(a_{0_{1}},(a_{0_{2}},...(a_{0_{j_{0}-1}},(a_{1_{0}},(a_{1_{1}},(a_{1_{2}},...(a_{1_{j_{1}-1}},\emptyset{})\dots{}))))\dots{})))\nonumber\\
\langle\overline{A_{0}}\{j_{0}\},\overline{A_{1}}\{j_{1}\},\overline{A_{2}}\{j_{2}\}\rangle &= (\overline{A_{0}}\{j_{0}\},(\overline{A_{1}}\{j_{1}\},(\overline{A_{2}}\{j_{2}\},\emptyset{})))=\nonumber\\
&=(a_{0_{0}},(a_{0_{1}},(a_{0_{2}},...(a_{0_{j_{0}-1}},(\overline{A_{1}}\{j_{1}\},(\overline{A_{2}}\{j_{2}\},\emptyset{})))\dots{})))
\end{align}
\p It is conceptually easy to inductively define the new m-tuple of different parameter packs forming a parameter pack itself using the "size" annotator.
\begin{align}
\underset{\forall m,j_{0},j_{1},j_{2},...,j_{m-1} \in \mathbb{Z}_{\geq 1}}{\overline{A}\{\Sigma_{i=0}^{m-1} j_{i}\}}
&=\underbrace{\overbrace{\langle\overline{A_{0}}\{j_{0}\},\overline{A_{1}}\{j_{1}\},\overline{A_{2}}\{j_{2}\},\dots\overline{A_{m-1}}\{j_{m-1}\}\rangle}^{sizeof...(A)=\Sigma_{i=0}^{m-1} j_{i}}}_{\bm{m-tuple}\text{ of different parameter packs.}}\nonumber\\&\Rightarrow\nonumber\\
\underset{\forall m,j_{0},j_{1},j_{2},...,j_{m-1} \in \mathbb{Z}_{\geq 1}}{\overline{A}\{\Sigma_{i=0}^{m-1} j_{i}\}}
&= (\overline{A_{0}}\{j_{0}\},(\overline{A_{1}}\{j_{1}\},(\overline{A_{2}}\{j_{2}\},...,(\overline{A_{m-1}}\{j_{m-1}\},\emptyset{})...)))
\end{align}
\p If multiple copies of this new pack were used in sequence to create a new pack through repetition, the following would hold for the case of a 2-tuple repetition:
\begin{align}
\underset{\forall m,j_{0},j_{1},j_{2},...,j_{m-1} \in \mathbb{Z}_{\geq 1}}{\langle\overline{A}\{\Sigma_{i=0}^{m-1} j_{i}\},\overline{A}\{\Sigma_{i=0}^{m-1} j_{i}\}\rangle}
&=\underbrace{\overbrace{\langle\overline{A_{0}}\{j_{0}\},\overline{A_{1}}\{j_{1}\},\overline{A_{2}}\{j_{2}\},\dots\overline{A_{m-1}}\{j_{m-1}\},\overline{A_{0}}\{j_{0}\},\overline{A_{1}}\{j_{1}\},\overline{A_{2}}\{j_{2}\},\dots\overline{A_{m-1}}\{j_{m-1}\}\rangle}^{2\times\Sigma_{i=0}^{m-1} j_{i}}}_{\bm{2\times{}m-tuple}\text{ of different parameter packs.}}\nonumber
\end{align}
\p Continuing this process by repeatedly expanding this new pack through multiple repeats of the original from which it started, we arrive at the general form for n repeats as is below by introducing a "pattern" annotator $[n]$ as a symbolic shorthand of the process.
\begin{align}
\underset{\forall n,m,j_{0},j_{1},j_{2},...,j_{m-1} \in \mathbb{Z}_{\geq 1}}{\overline{A}\{n\times\Sigma_{i=0}^{m-1} j_{i}\}[n]}
&=\underbrace{\overbrace{\langle\overline{A_{0}}\{j_{0}\},\overline{A_{1}}\{j_{1}\},\overline{A_{2}}\{j_{2}\},\dots\overline{A_{m-1}}\{j_{m-1}\},\dots,\overline{A_{0}}\{j_{0}\},\overline{A_{1}}\{j_{1}\},\overline{A_{2}}\{j_{2}\},\dots\overline{A_{m-1}}\{j_{m-1}\}\rangle}^{sizeof...(A)=n\times\Sigma_{i=0}^{m-1} j_{i}}}_{\bm{n\times{}m-tuple}\text{ of different parameter packs.}}
\end{align}
\p After formulating (7) as the "annotated" form of a template parameter pack, there is an interesting and intuitive observation of whether there can be an equivalence between the "annotated" form and template parameter packs so that any template parameter pack can be rewritten into an annotated form of another parameter pack for which explicit specification on its size and eventually occurring repetitive patterns may be specified.
\begin{align}
\underset{\exists j,n \in \mathbb{Z}_{\geq 1}}{\overline{A}} = \overline{A'}\{j\}[n]
\end{align}
There are just three cases where (8) has to be proven valid: the single parameter, the parameter pack and a series of parameters in a template parameter list that are not part of a parameter pack.
\begin{enumerate}
\item\p A single parameter may be viewed as the expansion of annotated pack with a single parameter, therefore for a given parameter $T$, there is indeed a $\overline{T'}$ when $j=n=1$, making $T$ equivalent to $\overline{T'}\{1\}[1]$:
\begin{align}
T \equiv \overline{T'}\{1\}[1]
\end{align}
\item\p A finite sequence of parameters of the same kind (non-type,type-type,template-type) $T_{0},T_{1},T_{1},...,T_{m-1}$ constituting an m-tuple themselves but not making part of a parameter pack but of an explicitely specified ordered sequence of parameters in the declaration of a template parameter list, can make use of the result of (9) and be rewritten in the form of an annotated pack as follows:
\begin{align}
\langle{}T_{0},T_{1},T_{2},...,T_{m-1}\rangle{} &=\langle{}\overline{T'_{0}}\{1\}[1],\overline{T'_{1}}\{1\}[1],\overline{T'_{2}}\{1\}[1],...,\overline{T'_{m-1}}\{1\}[1]\rangle{}=\nonumber\\
&=\overline{T'}\overbrace{\{1+1+...+1\}}^{m}[1] = \underset{j=m,n=1}{\overline{T'}\{m\}[1]} =\nonumber\\
&=\overline{T'}\{j\}[n]
\end{align}
\item\p It is trivial to generalize (10) for a variadic parameter pack $\overline{T}$ if we take advantage of $sizeof...(T)$, as follows:
\begin{align}
\overline{T} &= \langle{}T_{0},T_{1},T_{2},...,T_{sizeof...(T)-1}\rangle{}=\nonumber\\
&=\langle{}\overline{T'_{0}}\{1\}[1],\overline{T'_{1}}\{1\}[1],\overline{T'_{2}}\{1\}[1],...,\overline{T'_{sizeof...(T)-1}}\{1\}[1]\rangle{}=\nonumber\\
&=\underset{j=sizeof...(T'),n=1}{\overline{T'}\{sizeof...(T')\}[1]}=\nonumber\\
&=\overline{T'}\{j\}[n]
\end{align}
\item\p The last step is for cases where the "pattern" annotator is to have values greater than 1, as is the case when the parameter pack is constructed by multiple repetitions of another one:
\begin{align}
\overline{T} &= \langle{}\overbrace{\underbrace{T_{0},T_{1},T_{2},\dots,T_{m-1}}_{0}}^{m},\overbrace{\underbrace{T_{0},T_{1},T_{2},\dots,T_{m-1}}_{1}}^{m},\dots,\underbrace{T_{0},T_{1},T_{2},\dots,T_{m-1}}_{n-1}\rangle{}=\nonumber\\
&=\langle{}\underbrace{\overline{T'}\{m\}[1],\overline{T'}\{m\}[1],\dots,\overline{T'}\{m\}[1]}_{n}\rangle{}=\nonumber\\
&=\overline{T'}\{\underbrace{m+m+m+\dots+m}_{n}\}[n] = \overline{T'}\{\underset{j=n\times{m}}{n\times{m}}\}[n]=\nonumber\\
&=\overline{T'}\{j\}[n]
\end{align}
\item\p Even when a new parameter pack is constructed by mixing packs that are completely unrelated regarding number of parameter packs contained, provided they are of the same kind (non-type,type-type,template-type), annotated form can be used to describe them.
\begin{align}
\overline{T}&=\underset{\overline{T_{0}} \neq\overline{T_{1}}\neq\overline{T_{2}}\neq\dots\neq\overline{T_{m-1}}}{\langle{}\overline{T_{0}},\overline{T_{1}},\overline{T_{2}},\dots,\overline{T_{m-1}}\rangle} =\nonumber\\&= \langle\overline{T'_{0}}\{j_{0}\}[n_{0}],\overline{T'_{1}}\{j_{1}\}[n_{1}],\overline{T'_{2}}\{j_{2}\}[n_{2}],\dots,\overline{T'_{m-1}}\{j_{m-1}\}[n_{m-1}]\rangle{}=\nonumber\\
&=\underset{j=j_{0}+j_{1}+j_{2}+...+j_{m-1},n=1}{\overline{T'}\{j_{0}+j_{1}+j_{2}+...+j_{m-1}\}[1]}=\nonumber\\
&=\overline{T'}\{j\}[n]
\end{align}
\item\p Another way with which

\begin{align}
\underset{\forall i,j,k \in \mathbb{Z}_{\geq 1} \wedge{[i,j)\neq\emptyset}}{\overline{T}\{i,j\}[n]} &= \mathlarger{\mathlarger{\mathlarger{\{}}}\overline{X}\mid{}\overline{X}\{x\}[n] \wedge{k\in[i,j)}\mathlarger{\mathlarger{\mathlarger{\}}}}
\end{align}
\end{enumerate}

\subsection{Accessing individual elements in annotated and non-annotated packs}
\p \textit{{\color{tone1}There should be a few paragraphs here taking text from the old version.}}
\section{Using annotated template parameter packs}
\p \textit{{\color{tone1}There should be a few paragraphs here taking text from the old version.}}
\subsection{Individual accessors to parameter pack elements}
\p \textit{{\color{tone1}There should be a few paragraphs here taking text from the old version.}}
\subsection{Easier typelist implementation}
\p Annotated and non-annotated packs, can be combined for the explicit purpose of declarating constructs useful for manipulating typelists.
Class template partial specializations deploying substitutive ordering and type accessors can be mixed with a series of constant expressions in the annotated packs used that yield interesting results.

\p The following examples illustrate one possible implementation of the typelist concept using annotated packs, with the typevector class being named such due to type accessors yielding $O(1)$ access during compilation.

\begin{enumerate}
\item\p Initially, the \textit{typevector} class is defined, along with an {\textit{error\_type}} for convenience. Definitions for three different operations, namely {\textit{at\_pos}}, {\textit{alter\_at}} and {\textit{split\_at}} are made for individual type access at a given position, changing the type at a given position and splitting the typevector into two different ones at a given position. The default result is always the {\textit{error\_type}}.Take notice that partial specializations of the \textit{at\_pos}, \textit{alter\_at}, \textit{split\_at} templates having the annotation equivalent of a regular parameter pack, would cause ambiguity to ensue because of the equivalence between $...T\{0,sizeof...(T)\}$ and $...T$.

\item\p We begin with the bare fundamentals of \textit{error\_type} and \textit{typevector}.
\begin{minted}{c++}
struct error_type {};
/* the typevector is actually just a holder for a pack */
template<typename... X> struct typevector {};
\end{minted}
\item\p The interval annotator is used for declaring an annotated parameter pack in the following partial specializations of {\textit{at\_pos}}, where the constant expression of the right bound will resolve to $T\{0,0\}$ when access beyond the bounds is attempted.
This is not a valid interval, therefore this specialization will be removed from the viable candidates set due to SFINAE, with the unspecialized class template definition providing a better match. 
\begin{minted}{c++}
template<std::size_t N, typename>
struct at_pos { typedef error_type type; };

template< std::size_t N
        , typename... T{0,(N < sizeof...(T) ? sizeof...(T) : 0)}>
struct at_pos<N,typevector<T...>>
{ typedef T{N} type; };
\end{minted}

\item\p The combination of annotated and non-annotated packs can also be used for quickly altering the type parameter present at a given position in the {\textit{typevector}}.
Again, the interval annotation is deployed for placing invalid access through a constant expression evaluating to 0, forcing $T\{0,0\}$ when that is attempted.
\begin{minted}{c++}
template<std::size_t N, typename>
struct alter_at { typedef error_type type; };

template< std::size_t N
        , typename X
        , typename Z
        , typename... T{0,(N < sizeof...(T) ? sizeof...(T) : 0)} /* T{0,0} ! */
        , typename... R >
struct alter_at<N,X,typevector<T...{N-1},Z,R...>>
{ typedef typevector<T...{N-1},X,R...> type; };
\end{minted}
\item\p Splitting a {\textit{typevector}} into two halves at a given position is reduced to a problem of specifying the interval bounds correctly, with two constant expressions providing the same kind of $T\{0,0\}$ mediated SFINAE safety.
\begin{minted}{c++}
template<std::size_t N, typename>
struct split_at {
    typedef error_type first_half;
    typedef error_type secnd_half;
};

template< std::size_t N
        , typename... L{0,(N < sizeof...(L) ? sizeof...(L) : 0)}
        , typename... R{N,(N < sizeof...(R) ? sizeof...(R) : 0)} >
struct split_at<N,typevector<L...{N-1},R...{sizeof...(R)}>> { /* anchored ! */
    typedef typevector<L...> first_half; /* already anchored */
    typedef typevector<R...> secnd_half; /* already anchored */
};
\end{minted}

\item\p Given that in the context of the proposal $\bm{\overline{T}\{0,|\overline{T}|\}[1] \equiv \overline{T}\{0,|\overline{T}|\}}$ while $\bm{\overline{T}\{0,|\overline{T}|\}[0] \equiv \emptyset{}}$ with the latter invoking SFINAE since it would resolve to an empty set (making the template parameter list invalid) and $\overline{T}\{0,|\overline{T}|\}\equiv{\overline{T}\{|\overline{T}|\}}\equiv{\overline{T}\{\}}$, we can exploit the pattern annotator for an interesting rewrite of at least one of the partial specializations defined before, e.g. of {\textit{at\_pos}}:
\begin{minted}{c++}
template<std::size_t N, typename... T{}[N < sizeof...(T)]>
struct at_pos<N,typevector<T...>>
{ typedef T{N} type; };
\end{minted}
\end{enumerate}

\section{Technical specification}
\subsection{Grammar Additions}
\section{Acknowledgements}
The author would like to thank Ville Voutilainen, current C++ Standard Commitee EWG Chairman for strongly motivating the drafting of this document.
The "fixed pack size" initiative was originally presented on the C++ std-proposals mailing list by Maurice Bos\textsuperscript{citation pending}.

\addcontentsline{toc}{section}{References}
\printbibliography
\end{document}