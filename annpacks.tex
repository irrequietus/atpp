%%
%% George Makrydakis irrequietus@gmail.com>
%% Copyright (C) 2014, All Rights Reserved
%%
%% This is my first C++ proposal

\documentclass[ notitlepage
              , a4paper
              , twoside ]{article}

\usepackage{fontspec}
\usepackage[T1]{fontenc}
\usepackage{charter}
\usepackage[expert]{mathdesign}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{polyglossia}
\usepackage{xunicode}
\usepackage{xltxtra}
\usepackage{csquotes}
\usepackage{tabularx}

\usepackage[ usenames
           , dvipsnames ]{xcolor}

\usepackage[ outer=3.4cm
           , heightrounded
           , marginparwidth=6cm
           , marginparsep=0.5cm ]{geometry}

\usepackage[pdfauthor={George Makrydakis},
            pdftitle={Annotating C++ template parameter packs},
            pdfsubject={},
            pdfkeywords={ C++
                        , templates
                        , meta-programming
                        , template parameters
                        , template parameter packs
                        , pattern generation },
            pdfproducer={XeLateX with hyperref},
            unicode=true,
            pdfencoding=auto,
            pdfcreator={Xelatex}]{hyperref}

\usepackage{newtxtext}
\usepackage{newtxmath}
\usepackage{upgreek}
\usepackage{bookmark}
\usepackage{bm}
\usepackage{listings}
\usepackage{color}
\usepackage{tikz}
\usepackage{minted}
\usepackage{tcolorbox}
\usepackage{etoolbox}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{textcomp}
\usepackage{mparhack}
\usepackage{draftwatermark}
\usepackage{relsize}
\usepackage[nottoc,numbib]{tocbibind}
\usepackage[nodate]{datetime}
\usepackage{everypage} %%% solving page layout problems in different pages
\usepackage[backend=biber,sorting=nyt,natbib
           , doi=false]{biblatex}

%%% getting git revision information
\input{gitrev.tex}

%%% clearing month, day
\AtEveryBibitem{\clearfield{month}}
\AtEveryBibitem{\clearfield{day}}
%%% nobreakspace fix           
\DeclareTextCommandDefault{\nobreakspace}{\leavevmode\nobreak\ } 
            
%%% defining some colors I like using
\definecolor{tone0}{RGB}{190,58,238}
\definecolor{tone1}{RGB}{1,41,110}
\definecolor{tone3}{HTML}{002B36}

%%% the main language of this document is of course english.
\setmainlanguage{english}

%%% setting page style
\pagestyle{fancyplain}

%%% paragraph formatting
\setlength{\parskip}{0.2cm plus1mm minus1mm}
\setlength{\abovedisplayskip}{12pt}
\setlength{\abovedisplayshortskip}{12pt}
\setlength{\belowdisplayskip}{12pt}
\setlength{\belowdisplayshortskip}{12pt}

%%% settings for hyperlinks
\hypersetup{ unicode=true
           , colorlinks=true
           , linkcolor=Blue
           , citecolor=MidnightBlue
           , filecolor=magenta
           , urlcolor=magenta }

%%% activating everypage hooks for header geometry issues
\AddEverypageHook{%
    \ifthenelse{\value{page}=1}%
    {\renewcommand{\headheight}{72pt}}
    {\renewcommand{\headrulewidth}{0.0pt}}%
    {\renewcommand{\headrulewidth}{0.4pt}}%
}

%%% making 'minted' segments embedded into a colorbox           
\AtBeginEnvironment{minted}{\fontsize{8}{8}\selectfont}
    \BeforeBeginEnvironment{minted}{\begin{tcolorbox}}
\AfterEndEnvironment{minted}{\end{tcolorbox}}

\usemintedstyle{trac}

%%% A macro for referring to non-type, type, template template parameter types.
\newcommand{\typepack}[1]{$\bm{\uptau_{#1}$}}
\newcommand{\epack}[1]{$\overset{...}{#1}$}

%%% macros for numbering paragraphs, essentially the \p{} macro
\newcommand{\parnum}{\bfseries\arabic{parcount}}
\newcounter{parcount}
\newcommand\p{%
    \stepcounter{parcount}%
    \leavevmode\marginpar[\hfill\parnum]{\parnum}%
}

%%% cleanup all information related to fancy headers
\fancyhf{}

%%% set footer information
\fancyfoot[LO,RE]{\thepage{}\
\center{Copyright \textcopyright{2014} George Makrydakis\\
\texttt{\href{mailto:irrequietus@gmail.com}{irrequietus@gmail.com}}}}

%%% set header information. The first page header is slightly different
\fancyhead[LE,RO]{\ifthenelse{\value{page}=1}{{\begin{tabular}{r l}\
{\color{magenta}docnum} &  {\color{tone0} ONGOING DRAFT} \\
{\color{magenta}project} & Programming Language C++, EWG \\
{\color{magenta}date} & \date{\today{} \currenttime{} EEST} \\
{\color{magenta}author} & George Makrydakis \\
{\color{magenta}reply-to} & \texttt{\href{mailto:irrequietus@gmail.com}{irrequietus@gmail.com}} \\
{\color{tone1}revision} & \texttt{\GitShortRev{}}\\
\end{tabular}}}{\slshape Annotating C++ template parameter packs\\
\bf{\color{tone1}{current revision:} {\color{magenta} \GitShortRev{} - \date{\today{} \currenttime{} EEST}}}}}
    
%%% setting the width of the header ruler
\renewcommand{\headrulewidth}{0.2pt}
    
%%% watermark info for the draft stage
\SetWatermarkLightness{0.942}
\SetWatermarkScale{3}


\setlength{\headheight}{30pt}

%%% I do not want the language string present in each bibliography item.
\renewbibmacro{in:}{}%
\AtEveryBibitem{%
  \clearlist{language}%
}

\addbibresource{annpacks.bib}



\begin{document}

\bookmark[dest=TitlePage]{Annotating C++ template parameter packs}

\title{Annotating C++ template parameter packs}
\author{George Makrydakis\\
\texttt{\href{mailto:irrequietus@gmail.com}{irrequietus@gmail.com}}\\\bf{{\
\color{magenta}UNCORRECTED INCOMPLETE DRAFT
\date{\bf{\today{} \currenttime{} EEST}}}}\\
\color{tone0}\texttt{\GitLongRev}}
\maketitle


\begin{abstract}
\p Parametric polymorphism in C++\cite{cpp11} is implemented through class and function templates whose parameter types refer to three different abstractions used for template declarations: template non-type, template type and template-template type parameters.
Since C++11, a fourth kind of template parameter abstraction known as the template parameter pack has been introduced, expressing an ordered sequence of a variable number of parameter types, the exact specifics of which to be decided during instantiation.

\p In their current incarnation, template parameter packs do not have any notation explicitely descriptive of their size and/or actual expansion intent.
Resourceful combinations of parameter packs with partial specializations, SFINAE, ADL and partial ordering are extensively deployed in several template programming and meta-programming techniques for code generation purposes.

\p This proposal argues that \textit{optionally annotating C++ template parameter packs} in a backwards compatible manner with information about size, repetition and patterned expansion during their use in template parameter lists can be detrimental in reducing the cost of using templates as computational constructs within a given translation unit.
As a result, code generation techniques based on simple template programming and meta-programming would require less source code boilerplate containing templates or relying to type-unsafe C++ preprocessor meta-programming to be required.
\end{abstract}


{\color{red}\textbf{DISCLAIMER: }}\textit{{\color{tone1} The current document is a publically disclosed but uncorrected and incomplete draft for a developing C++ proposal as was announced in the ISO C++ Standard - Future Proposals mailing list \cite{Mak2014}.
{\textbf{\color{red}{It is not a complete work yet.}}}
As a consequence, several errors, omissions, repetitions or inadequate development of the notions exposed are to be taken care of in future releases of this document.
In order to refer to contents of this particular draft, use its short revision identifier (e.g. {\color{magenta}{\GitShortRev{}}}) slashed with the paragraph number as it appears in side margins of the draft (e.g. {\color{magenta}{\GitShortRev{}}/1}).
The author will periodically release newer versions of this document at \href{http://atpp.irrequietus.eu}{http://atpp.irrequietus.eu} in good will, in hope of them being useful in a fruitful discussion on the subject of extending C++ template parameter packs.}}

\section{Introduction}
\p Template parameter packs can be viewed as product types from a type-theoretical point of view, with cohere but undecided boundary semantics in both their declaration and expansion within a given template parameter list, until the template containing them is a valid instantiative match.

\p Partial ordering and partial specializations allow for a type-driven kind of pattern matching to occur, becoming one of the two fundamentals  for any serious kind of C++ template meta-programming.
Recursive template instantiations and using declarations after recursive derivations of such instantiations offer the other fundamental construct for parameter list and resolution set manipulation within class template definition.

\p While parameter packs greatly enhance such C++ template meta-programming tools, they are just an omnicomprehensive abstraction into zero or more parameters without specifying certain constraints that included parameters must satisfy.
This leads to increased source code boilerplate in the ever-often occasion where type-driven pattern matching has to be used for formulating template meta-programming constructs since this kind of pattern matching is dependent on specific sequences of types being present, with or without patterned repetition.
\textit{Template parameter pack annotation} is a potential solution to this problem.

\section{Motivation}
\p The explicit goal of \textit{template parameter pack annotation} is to offer a optional extension to the current parameter pack declaration and expansion, through which constraints on the sequences and patterns contained within a given parameter pack may be specified for the explicit purpose of reducing source code boilerplate whenever the nowadays often used type-mediated pattern matching in C++ template meta-programming occurs.
In its simplest case, such annotation results in producing parameter packs of finite ("fixed") size.
In its more general case, allows for easy manipulation of sets of parameter packs within the domain of class template partial specializations.
In either case, it can contemporaneously offer control over the actual contents of a parameter pack within the template parameter list declaration \textit{without requiring breaking changes to be introduced with past and ongoing C++ standards}.

\p \textit{Template pack annotators}, are constant expressions enclosed within $\mathlarger{\bm{\{\}}}$ and $\mathlarger{\bm{[]}}$ immediately following parameter pack declaration, where the parameter pack identifier itself can participate in valid C++11/C++14 context.
\textit{Template parameter pack annotation} depends on proper use of the \textit{annotators}, the semantics of which are analyzed and expanded upon in the following subsections.

\subsection{Using patterns as input for pattern matching}
\p The following source code example is C++11/C++14 compliant and illustrates
some simple ways through which manipulation of template parameter pack declaration
and expansion are practiced. It becomes quite apparent that because of the
abstraction packs offer, variadic template parameter and argument lists can be
useful computational constructs during template instantiations. In the
following example, a template
parameter pack is declared, manipulated and expanded in a variety of ways
fully compatible with the C++11/C++14 standard. Once compiled, the resulting
binary prints a series of strings on the terminal that are dependent upon
the C++ features used as computational devices during instantiation phase.

\begin{minted}{c++}

template<typename... Types_T>
struct packed;

template<typename Head, typename... Tail>
struct packed<Head,Tail...> {
    typedef packed<Tail...> pop_front;
};

template<>
struct packed<>
{ typedef packed<> pop_front; };
\end{minted}
\begin{minted}{c++}
template<typename... T>
void function(packed<T...>) {
    printf("%d types contained\n", sizeof...(T));
    function(typename packed<T...>::pop_front());
}
\end{minted}
\begin{minted}{c++}
template<typename... X, typename... Y>
void function(packed<X...,long,Y...>) {
    printf( "%d types contained and a long found!\n"
          , sizeof...(X) + sizeof...(Y) + 1);
    function(typename packed<X...,long,Y...>::pop_front());
}
\end{minted}
\begin{minted}{c++}
template<typename T,typename...X>
void function(packed<T,T,X...>) {
    printf("%d IDENTICAL types found out of %d \n", 2, sizeof...(X)+3);
    function(typename packed<T,T,X...>::pop_front());
}
\end{minted}
\begin{minted}{c++}
template<typename X, typename Y, typename...T>
void function(packed<X,Y,T...>) {
    printf("just %d DIFFERENT types contained\n", 2 + sizeof...(T));
    function(typename packed<X,Y,T...>::pop_front());
}
\end{minted}
\begin{minted}{c++}
void function(packed<>) {
    printf("no types contained anymore!\n");
}
\end{minted}
\begin{minted}{c++}
int main() {
   function(packed<char,short,short,long,short,int,int>());
   return {};
}

\end{minted}

\subsection{Context dependency of pack declaration and expansion}

\p From the example above, it is evident that pattern matching during
instantiation is evidently occuring even on specified
ordered sequences of type patterns in the left bound of a template parameter/argument
list. For this to happen, whenever template
parameter packs are involved, they have to be allowed expansion into the actual
ordered type sequences they abstract in order for things like partial
ordering to be respected. This occurs only when the context where
these packs appear in a template parameter list allows for the parameters
involved to be deduced. Let's begin with a very simple duo of variadic class
templates in the following code segment:

\begin{minted}{c++}
template<typename...>
struct wrapper {};

template<typename... T>
struct some_template {
    static void hello()
    { printf("hello world!\n"); }
};
\end{minted}


\p A few simple class template partial specializations
can help illustrating when the pack declaration and expansion are allowed. Notice
that in both specializations that follow, the template parameter pack is not
expanded within the same template parameter list where it was declared and
is ordered as the last argument used (right bound of the template argument
list of the class template partial specialization). This allows for the pack to be expanded
within a context where the totality of parameters turned arguments can be deduced,
therefore correct and specialized instantiation to occur:

\begin{minted}{c++}
template<typename... X>
struct some_template<wrapper<X...>,int> { /* X is alone! */
    static void hello()
    { printf("hello world from wrapper!\n"); }
};

template<typename... X>
struct some_template<wrapper<int,X...>,int> { /* rightmost X! */
    static void hello()
    { printf("the first type in the wrapper is an int...\n"); }
};
\end{minted}

\p The order of appearance in a given template parameter/argument list of a
parameter pack respect to non-pack template parameters is the single most
important constraint for allowing the deduction of all parameters involved
and thus pack expansion. In the following example, due to the pack appearing
before a non-pack parameter the compiler cannot deduce all the parameters
involved when the pack is required to expand in the template argument
list the following class template partial specialization:

\begin{minted}{c++}
template<typename... X>
struct some_template<wrapper<X...,int>,int> { /* cannot deduce parameters! */
    static void hello()
    { printf("this code is wrong!"); }
};

template<typename...X>
struct some_template<X...,int> { /* cannot deduce parameters! */
    static void hello()
    { printf("this code is also wrong!\n"); }
};
\end{minted}

\p This behaviour is consistent in both class template partial specializations
and function template declarations even when multiple template parameter
pack declarations exist in a given template parameter/argument list. An example
where these are deployed follows. Notice the ordering of the packs required to expand
within each instantiation of class template I, allowing for all parameters
to be deduced:

\begin{minted}{c++}
/*  Multiple pack expansion in a context where parameters can be deduced! */
template<typename... A, typename... B, template<typename...> class I>
void function(I<A...>,I<B...>)
{ printf("multiple parameter packs in function templates are ok!\n"); }
\end{minted}

\p As useful as template parameter packs are, their
declaration and expansion semantics can only currently abstract an ordered sequence
of parameters of "unconstrained" length in both scenarios. Parameter packs
cannot expand
within the same template parameter list where they are declared because of
their unbound expansion compromising parameter deduction and partial
ordering in both class and function templates. The same rule is
valid for template argument lists. However,
unsurprisingly, the following code
works because the parameter pack is required to expand within class template
scope, where the all parameters have already been deduced during
instantiation and thus the argument list of the enclosed member function
is valid.:

\begin{minted}{c++}
template<typename... X>
struct working {
    typedef wrapper<X...,int> type;
    
    static void function(X...,int) {
        printf("surprised to see me?\n");
    }
};
\end{minted}

\p In essence, template parameter pack ordering is constrained to be right-bound
in parameter and argument lists due to its unconstrained expansion
compromising the deducibility of all the parameters involved, a feature
necessary for pattern matching to occur.
By specifying certain constraints in pack declaration
and/or expansion we would be forcing the creation of specific template parameter
and argument lists in contexts where parameter deduction is unattainable. In
the simplest case, expanding a parameter pack in the left bound of a parameter/argument
list with such constraints
would yield a finite amount of parameters ("fixed pack size") of the same type
(non-type,type, template type) for which partial ordering rules would be
safe to apply. In the more general case, also decide which of the types
contained already present in the pack should expand when certain constraints are met,
allowing again the selective nature of partial ordering to occur.

\subsection{Conventions followed during analysis}
\p For the purposes of conceptualization, we are going to borrow and admittedly abuse some of the mathematical notation available for formulations to which we will mix $\mathlarger{\bm{\{\}[]}}$ as "annotator" symbols for template parameter packs.
These two annotators will be providing unambiguous intent when translating to C++ code that is considered to be valid in the context of this proposal.
A C++ template parameter pack $...T$ will be symbolized as a capital letter with an overline (i.e. $\overline{T}$), while the $\bm{sizeof...(T)}$ constant expression will be symbolized as $|\overline{T}|$.

\p Unless otherwise specified, all other notation used in the following formulation refers to its pristine mathematical meaning.
At the current stage of this incomplete draft, there may be unintentional discrepancies that have to be corrected and will be in a newer version of this draft.
\subsubsection{Fundamentals of parameter pack annotation}
\begin{enumerate}
\item\p When $\mathlarger{\bm{\{N\}}}$ or $\mathlarger{\bm{\{N,K\}}}$ or $\mathlarger{\bm{\{\}}}$ are used, they are referring to constant expressions $N$ and $K$ used in the context of the \textit{interval annotator}.
The first case specifies that the given pack is actually a shorthand for a parameter sequence consisting of exactly $N$ parameters of the same kind (non-type,type-type,template-type).
When two comma-separated constant expressions are used, the \textit{interval annotator} refers to the a valid right-open interval of $[N,K)\in\mathbb{Z}_{\geq 1}$ within which the size of a pack matching the expression should be in order for the match to be valid.
When no expressions are used as in the last case, the intent for a pack $\overline{T}$ is equivalent to $\mathlarger{\bm{\{|\overline{T}|\}}}$ and $\mathlarger{\bm{\{0,|\overline{T}|\}}}$ which are \textit{interval annotation} for a parameter pack of zero or more parameters of the same kind (non-type,type-type,template-type).
\item\p When $\mathlarger{\bm{[]}}$ or $\mathlarger{\bm{[]}}$ or $\mathlarger{\bm{[N]}}$ are used, the \textit{pattern annotator} specifies that said annotated pack is made out of either 1 (i.e. $[]$ or $[1]$) or more ($[N]$) repetitions of the same sequence of types.
The size of the pack does not get altered by the \textit{pattern annotator} but in order for such an annotated pack to be a valid match, its size must be an exact multiple of the constant expression in the \textit{pattern annotator}.
\item\p An annotated template parameter pack is an n-ordered sequence of zero or more template parameters of the same type (non-type, type-type, template-type) whose identifier is followed by the \textit{interval} and \textit{pattern} annotators.
The \textit{interval annotator} must always precede the \textit{pattern annotator} while both follow the identifier used for the \textit{annotated template parameter pack}.
\item\p When the \textit{interval} annotator is used with a single constant expression, it can be referred to as \textit{anchoring annotator} and the annotation itself referred to as \textit{anchoring annotation} regardless of whether a \textit{pattern annotator} follows or not.
\item\p Annotated parameter packs that are coexisting with non-annotated parameter packs gain precedence in partial ordering over the latter unless they are equivalent forms, in which case a match cannot be made.
When \textit{anchoring annotation} is present, annotated parameter packs submit to the same matching rules as their equivalent parameter lists where parameters of the same kind (non-type, type-type, template-type) are deterministically specified in a non-pack form in the declaration of their template parameter list.
\item\p The use of \textit{full interval annotation} is permitted only in class templates since for each pack having \textit{full interval annotation}, a set of parameter lists whose rank equals the rank of the annotation interval is intended to be used, in the form of either class template partial specializations or nested class and function templates within the definition body whose template parameter list contains the \textit{full-interval} annotated pack.
\item\p When the \textit{pattern annotator} is used in the context of a template argument list, it resolves to expanding the preceding pack as many times as the \textit{pattern factor} dictates.
\item\p When \textit{full interval annotation} is used in the declaration of a template parameter list for a given pack, that pack can must be expanded using \textit{anchoring annotation} within the template parameter list of a class or function template.
Anchoring annotation may be omitted in expansion, but when deployed, the anchoring annotator may not enclose a constant expression whose evaluation would yield an anchor factor outside the interval specified.
\item\p When \textit{anchoring annotation} has been used upon a pack, each parameter may be accessed individually at a given position by using the pack identifier followed by \textit{anchoring annotation} of a constant expression indicating that position.
This way of access cannot modify any parameter type present at a given position nor can it be used with non-annotated packs.
\item\p Multiple anchoring annotated packs may be present at any order within a template parameter list because unlike their non-annotated and interval annotated counterparts, they are deterministically specified in a context where deducibility is guaranteed.
\end{enumerate}
\subsubsection{Why individual accessors are inevitable}
\p One of the characteristics of the parameter pack is the inability to access individual parameters contained for a given index.
While this character may be acceptable for parameter packs as they stand right now in the C++11/C++14 standards, proposing any kind of "fixed size packs" even as convenient shorthands rapidly introduces two additional problems.
In order to analyze these, we will use $\bm{()}$ enclosed constant expressions for referring to isolated "fixed size packs" in order to separate the context of such proposals with the context of our current draft.

\begin{enumerate}
\item\p Given a parameter pack $T$ that has "fixed size pack" semantics (i.e. always expanding to a non-changing, pre-determined ordered sequence of parameters) poses the problem of using those individual parameters within constructs in template argument lists and within template definition body.
This does not happen with parameter packs as we know them because they do not expand to pre-determined ordered sequences of known length, with their use being limited in specifying recursive instantiations and calls in class and function templates respectively.
\begin{minted}{c++}
/* theoretical code in the context of another proposal: "fixed size packs".*/
template<typename...(3) Args_T> /* = template<typename,typename,typename> */
struct class_template
{ /* how are "fixed size packs" different from regular packs? */ };

template<typename...(3) Args_T> /* = template<typename,typename,typename> */
void function(Args_T... args)   /* "fixed size pack" expanding syntax */
{ /* how are args going to be used differently from regular packs? */ }
\end{minted}
\item\p Even if "fixed size packs" are introduced lacking individual accessors, it would be trivial enough for programmers of any level of C++ expertise to write a simple class template providing the same effect, to the point of becoming a nuissance not having it in the standard as a library feature in the context of "fixed size packs" proposals.
\begin{minted}{c++}
template<std::size_t N, typename... Args_T>
struct fixed_atpos {
    public:
        struct access_error {};
    private:
        template<typename...(K) Fixed_T, typename X, typename... Types_T>
        static typename std::enable_if<(K < sizeof...(Args_T)),X>::type
        impl(Fixed_T...,X,Types_T...); /* fixed (determined) pack = ok */
        
        static access_error impl(...);
    public:
        typedef decltype(impl(std::declval<Args_T>()...)) type;
};
\end{minted}
\p Such idea easily prompts for simplification just as was the case with \textit{std::enable\_if}\cite{JarviWL03} - like templates using template aliases in C++14 or the abbreviated form of \textit{for} loops, in a context where \textit{fixed\_atpos} is valid.
\begin{minted}{c++}
template<std::size_t N, typename... Args_T>
using fixed_atpos_t = typename fixed_atpos<N,Args_T...>::type;
\end{minted}
\end{enumerate}

\subsubsection{Understanding annotation equivalence}
\p First, a parameter pack is an n-ordered sequence (n-tuple) of zero or more parameter types of the same kind (non-type, type-type, template-type).
They can be viewed as product types and modelled using nested ordered pairs, in a way reminiscent of a left/right fold of a cons function over the n-tuple that they actually are.
The following two equivalent formulations inductively define a template parameter pack of $t_{0},t_{1},t_{2},...t_{n-1}$ are known to be valid representational approaches.
The most basic annotator equivalence is added to both.
\begin{align}
\overline{X}
    &\equiv \overline{X}\{\}[] = \underbrace{( t_{0}
                   , ( t_{1}
                     , (t_{2}
                     , ( \dots{}
                      , ( t_{n-1},\emptyset)\dots))))}_{n=|\overline{X}|=sizeof...(X)}\\
\overline{Y}
    &\equiv \overline{Y}\{\}[] = \underbrace{((\dots{} (((\emptyset{},t_{0})
                   ,  t_{1})
                     , t_{2})
                     ,  \dots{}
                      ), t_{n-1})}_{n=|\overline{Y}|=sizeof...(Y)}
\end{align}
\p We will be using the $\overline{X}$ formulation from now on, with an \textit{annotator} next to parameter pack declaration containing the size of the pack enclosed in curly braces as $\bm{\{j\}}$, when the intention is to force the j-tuple of contained elements that the pack is into a finite and well defined equivalent of the non-variadic form of said pack, which would be preferentially matched over the variadic form should the two coexist.
When either $\overline{T}\{sizeof...(T)\}$ or $\overline{T}\{|\overline{T}|\}$ are used, these are completely equivalent to declaring $\overline{T}\{\}$ and $\overline{T}$ and therefore the "size" annotation may be ommited.

\p Another important operation can also be modelled after valid C++11/C++14 code like the following (\textit{wrapper} and \textit{error\_type} were defined previously) when it comes to the semantics of joining two parameter packs of the same kind:
\begin{minted}{c++}
/* NOTE: valid C++11,C++14 code */
template<typename,typename>
struct join_packs
{ typedef error_type type; };

template<typename... A0, typename... A1>
struct join_packs<wrapper<A0...>,wrapper<A1...>>
{ typedef wrapper<A0...,A1...> type; };
\end{minted}
This will be formulated through the following convention that can be generalized for an arbitrary amount of parameter packs, having any variation of size and ordered sequence of types abstracted in said packs:
\begin{align}
\langle\overline{A_{0}}\{j_{0}\}\rangle &= (\overline{A_{0}}\{j_{0}\},\emptyset{}) =\nonumber\\
&=(a_{0_{0}},(a_{0_{1}},(a_{0_{2}},...(a_{0_{j_{0}-1}},\emptyset{})\dots{})))\\
\langle\overline{A_{0}}\{j_{0}\},\overline{A_{1}}\{j_{1}\}\rangle &= (\overline{A_{0}}\{j_{0}\},(\overline{A_{1}}\{j_{1}\},\emptyset{}))=\nonumber\\
&=(a_{0_{0}},(a_{0_{1}},(a_{0_{2}},...(a_{0_{j_{0}-1}},\overline{A_{1}}\{j_{1}\})\dots{})))\\
&=(a_{0_{0}},(a_{0_{1}},(a_{0_{2}},...(a_{0_{j_{0}-1}},(a_{1_{0}},(a_{1_{1}},(a_{1_{2}},...(a_{1_{j_{1}-1}},\emptyset{})\dots{}))))\dots{})))\nonumber\\
\langle\overline{A_{0}}\{j_{0}\},\overline{A_{1}}\{j_{1}\},\overline{A_{2}}\{j_{2}\}\rangle &= (\overline{A_{0}}\{j_{0}\},(\overline{A_{1}}\{j_{1}\},(\overline{A_{2}}\{j_{2}\},\emptyset{})))=\nonumber\\
&=(a_{0_{0}},(a_{0_{1}},(a_{0_{2}},...(a_{0_{j_{0}-1}},(\overline{A_{1}}\{j_{1}\},(\overline{A_{2}}\{j_{2}\},\emptyset{})))\dots{})))
\end{align}
\p It is conceptually easy to inductively define the new m-tuple of different parameter packs forming a parameter pack itself using the "size" annotator.
\begin{align}
\underset{\forall m,j_{0},j_{1},j_{2},...,j_{m-1} \in \mathbb{Z}_{\geq 1}}{\overline{A}\{\Sigma_{i=0}^{m-1} j_{i}\}}
&=\underbrace{\overbrace{\langle\overline{A_{0}}\{j_{0}\},\overline{A_{1}}\{j_{1}\},\overline{A_{2}}\{j_{2}\},\dots\overline{A_{m-1}}\{j_{m-1}\}\rangle}^{sizeof...(A)=\Sigma_{i=0}^{m-1} j_{i}}}_{\bm{m-tuple}\text{ of different parameter packs.}}\nonumber\\&\Rightarrow\nonumber\\
\underset{\forall m,j_{0},j_{1},j_{2},...,j_{m-1} \in \mathbb{Z}_{\geq 1}}{\overline{A}\{\Sigma_{i=0}^{m-1} j_{i}\}}
&= (\overline{A_{0}}\{j_{0}\},(\overline{A_{1}}\{j_{1}\},(\overline{A_{2}}\{j_{2}\},...,(\overline{A_{m-1}}\{j_{m-1}\},\emptyset{})...)))
\end{align}
\p If multiple copies of this new pack were used in sequence to create a new pack through repetition, the following would hold for the case of a 2-tuple repetition:
\begin{align}
\underset{\forall m,j_{0},j_{1},j_{2},...,j_{m-1} \in \mathbb{Z}_{\geq 1}}{\langle\overline{A}\{\Sigma_{i=0}^{m-1} j_{i}\},\overline{A}\{\Sigma_{i=0}^{m-1} j_{i}\}\rangle}
&=\underbrace{\overbrace{\langle\overline{A_{0}}\{j_{0}\},\overline{A_{1}}\{j_{1}\},\overline{A_{2}}\{j_{2}\},\dots\overline{A_{m-1}}\{j_{m-1}\},\overline{A_{0}}\{j_{0}\},\overline{A_{1}}\{j_{1}\},\overline{A_{2}}\{j_{2}\},\dots\overline{A_{m-1}}\{j_{m-1}\}\rangle}^{2\times\Sigma_{i=0}^{m-1} j_{i}}}_{\bm{2\times{}m-tuple}\text{ of different parameter packs.}}\nonumber
\end{align}
\p Continuing this process by repeatedly expanding this new pack through multiple repeats of the original from which it started, we arrive at the general form for n repeats as is below by introducing a "pattern" annotator $[n]$ as a symbolic shorthand of the process.
\begin{align}
\underset{\forall n,m,j_{0},j_{1},j_{2},...,j_{m-1} \in \mathbb{Z}_{\geq 1}}{\overline{A}\{n\times\Sigma_{i=0}^{m-1} j_{i}\}[n]}
&=\underbrace{\overbrace{\langle\overline{A_{0}}\{j_{0}\},\overline{A_{1}}\{j_{1}\},\overline{A_{2}}\{j_{2}\},\dots\overline{A_{m-1}}\{j_{m-1}\},\dots,\overline{A_{0}}\{j_{0}\},\overline{A_{1}}\{j_{1}\},\overline{A_{2}}\{j_{2}\},\dots\overline{A_{m-1}}\{j_{m-1}\}\rangle}^{sizeof...(A)=n\times\Sigma_{i=0}^{m-1} j_{i}}}_{\bm{n\times{}m-tuple}\text{ of different parameter packs.}}
\end{align}
\p After formulating (7) as the "annotated" form of a template parameter pack, there is an interesting and intuitive observation of whether there can be an equivalence between the "annotated" form and template parameter packs so that any template parameter pack can be rewritten into an annotated form of another parameter pack for which explicit specification on its size and eventually occurring repetitive patterns may be specified.
\begin{align}
\underset{\exists j,n \in \mathbb{Z}_{\geq 1}}{\overline{A}} = \overline{A'}\{j\}[n]
\end{align}
There are just three cases where (8) has to be proven valid: the single parameter, the parameter pack and a series of parameters in a template parameter list that are not part of a parameter pack.
\begin{enumerate}
\item\p A single parameter may be viewed as the expansion of annotated pack with a single parameter, therefore for a given parameter $T$, there is indeed a $\overline{T'}$ when $j=n=1$, making $T$ equivalent to $\overline{T'}\{1\}[1]$:
\begin{align}
T \equiv \overline{T'}\{1\}[1]
\end{align}
\item\p A finite sequence of parameters of the same kind (non-type,type-type,template-type) $T_{0},T_{1},T_{1},...,T_{m-1}$ constituting an m-tuple themselves but not making part of a parameter pack but of an explicitely specified ordered sequence of parameters in the declaration of a template parameter list, can make use of the result of (9) and be rewritten in the form of an annotated pack as follows:
\begin{align}
\langle{}T_{0},T_{1},T_{2},...,T_{m-1}\rangle{} &=\langle{}\overline{T'_{0}}\{1\}[1],\overline{T'_{1}}\{1\}[1],\overline{T'_{2}}\{1\}[1],...,\overline{T'_{m-1}}\{1\}[1]\rangle{}=\nonumber\\
&=\overline{T'}\overbrace{\{1+1+...+1\}}^{m}[1] = \underset{j=m,n=1}{\overline{T'}\{m\}[1]} =\nonumber\\
&=\overline{T'}\{j\}[n]
\end{align}
\item\p It is trivial to generalize (10) for a variadic parameter pack $\overline{T}$ if we take advantage of $sizeof...(T)$, as follows:
\begin{align}
\overline{T} &= \langle{}T_{0},T_{1},T_{2},...,T_{sizeof...(T)-1}\rangle{}=\nonumber\\
&=\langle{}\overline{T'_{0}}\{1\}[1],\overline{T'_{1}}\{1\}[1],\overline{T'_{2}}\{1\}[1],...,\overline{T'_{sizeof...(T)-1}}\{1\}[1]\rangle{}=\nonumber\\
&=\underset{j=sizeof...(T'),n=1}{\overline{T'}\{sizeof...(T')\}[1]}=\nonumber\\
&=\overline{T'}\{j\}[n]
\end{align}
\item\p The last step is for cases where the "pattern" annotator is to have values greater than 1, as is the case when the parameter pack is constructed by multiple repetitions of another one:
\begin{align}
\overline{T} &= \langle{}\overbrace{\underbrace{T_{0},T_{1},T_{2},\dots,T_{m-1}}_{0}}^{m},\overbrace{\underbrace{T_{0},T_{1},T_{2},\dots,T_{m-1}}_{1}}^{m},\dots,\underbrace{T_{0},T_{1},T_{2},\dots,T_{m-1}}_{n-1}\rangle{}=\nonumber\\
&=\langle{}\underbrace{\overline{T'}\{m\}[1],\overline{T'}\{m\}[1],\dots,\overline{T'}\{m\}[1]}_{n}\rangle{}=\nonumber\\
&=\overline{T'}\{\underbrace{m+m+m+\dots+m}_{n}\}[n] = \overline{T'}\{\underset{j=n\times{m}}{n\times{m}}\}[n]=\nonumber\\
&=\overline{T'}\{j\}[n]
\end{align}
\item\p Even when a new parameter pack is constructed by mixing packs that are completely unrelated regarding number of parameter packs contained, provided they are of the same kind (non-type,type-type,template-type), annotated form can be used to describe them.
\begin{align}
\overline{T}&=\underset{\overline{T_{0}} \neq\overline{T_{1}}\neq\overline{T_{2}}\neq\dots\neq\overline{T_{m-1}}}{\langle{}\overline{T_{0}},\overline{T_{1}},\overline{T_{2}},\dots,\overline{T_{m-1}}\rangle} =\nonumber\\&= \langle\overline{T'_{0}}\{j_{0}\}[n_{0}],\overline{T'_{1}}\{j_{1}\}[n_{1}],\overline{T'_{2}}\{j_{2}\}[n_{2}],\dots,\overline{T'_{m-1}}\{j_{m-1}\}[n_{m-1}]\rangle{}=\nonumber\\
&=\underset{j=j_{0}+j_{1}+j_{2}+...+j_{m-1},n=1}{\overline{T'}\{j_{0}+j_{1}+j_{2}+...+j_{m-1}\}[1]}=\nonumber\\
&=\overline{T'}\{j\}[n]
\end{align}
\item\p Another way with which

\begin{align}
\underset{\forall i,j,k \in \mathbb{Z}_{\geq 1} \wedge{[i,j)\neq\emptyset}}{\overline{T}\{i,j\}[n]} &= \mathlarger{\mathlarger{\mathlarger{\{}}}\overline{X}\mid{}\overline{X}\{x\}[n] \wedge{k\in[i,j)}\mathlarger{\mathlarger{\mathlarger{\}}}}
\end{align}
\end{enumerate}
\section{Deployment scenarios}
\subsection{Easier typelist implementation}
\p Annotated and non-annotated packs, can be combined for the explicit purpose of declarating constructs useful for manipulating typelists \cite{Czarnecki2000,Alexandrescu2001,Abrahams2004}.
Class template partial specializations deploying substitutive ordering and type accessors can be mixed with a series of constant expressions in the annotated packs used that yield interesting results.

\p The following examples illustrate one possible implementation of the typelist concept using annotated packs, with the typevector class being named such due to type accessors yielding $O(1)$ access during compilation.

\begin{enumerate}
\item\p Initially, the \textit{typevector} class is defined, along with an {\textit{error\_type}} for convenience. Definitions for three different operations, namely {\textit{at\_pos}}, {\textit{alter\_at}} and {\textit{split\_at}} are made for individual type access at a given position, changing the type at a given position and splitting the typevector into two different ones at a given position. The default result is always the {\textit{error\_type}}.Take notice that partial specializations of the \textit{at\_pos}, \textit{alter\_at}, \textit{split\_at} templates having the annotation equivalent of a regular parameter pack, would cause ambiguity to ensue because of the equivalence between $...T\{0,sizeof...(T)\}$ and $...T$.

\item\p We begin with the bare fundamentals of \textit{error\_type} and \textit{typevector}.
\begin{minted}{c++}
struct error_type {};
/* the typevector is actually just a holder for a pack */
template<typename... X> struct typevector {};
\end{minted}
\item\p The interval annotator is used for declaring an annotated parameter pack in the following partial specializations of {\textit{at\_pos}}, where the constant expression of the right bound will resolve to $T\{0,0\}$ when access beyond the bounds is attempted.
This is not a valid interval, therefore this specialization will be removed from the viable candidates set due to SFINAE, with the unspecialized class template definition providing a better match. 
\begin{minted}{c++}
template<std::size_t N, typename>
struct at_pos { typedef error_type type; };

template< std::size_t N
        , typename... T{0,(N < sizeof...(T) ? sizeof...(T) : 0)}>
struct at_pos<N,typevector<T...>>
{ typedef T{N} type; };
\end{minted}

\item\p The combination of annotated and non-annotated packs can also be used for quickly altering the type parameter present at a given position in the {\textit{typevector}}.
Again, the interval annotation is deployed for placing invalid access through a constant expression evaluating to 0, forcing $T\{0,0\}$ when that is attempted.
\begin{minted}{c++}
template<std::size_t N, typename>
struct alter_at { typedef error_type type; };

template< std::size_t N
        , typename X
        , typename Z
        , typename... T{0,(N < sizeof...(T) ? sizeof...(T) : 0)} /* T{0,0} ! */
        , typename... R >
struct alter_at<N,X,typevector<T...{N-1},Z,R...>>
{ typedef typevector<T...{N-1},X,R...> type; };
\end{minted}
\item\p Splitting a {\textit{typevector}} into two halves at a given position is reduced to a problem of specifying the interval bounds correctly, with two constant expressions providing the same kind of $T\{0,0\}$ mediated SFINAE safety.
\begin{minted}{c++}
template<std::size_t N, typename>
struct split_at {
    typedef error_type first_half;
    typedef error_type secnd_half;
};

template< std::size_t N
        , typename... L{0,(N < sizeof...(L) ? sizeof...(L) : 0)}
        , typename... R{N,(N < sizeof...(R) ? sizeof...(R) : 0)} >
struct split_at<N,typevector<L...{N-1},R...{sizeof...(R)}>> { /* anchored ! */
    typedef typevector<L...> first_half; /* already anchored */
    typedef typevector<R...> secnd_half; /* already anchored */
};
\end{minted}

\item\p Given that in the context of the proposal $\bm{\overline{T}\{0,|\overline{T}|\}[1] \equiv \overline{T}\{0,|\overline{T}|\}}$ while $\bm{\overline{T}\{0,|\overline{T}|\}[0] \equiv \emptyset{}}$ with the latter invoking SFINAE since it would resolve to an empty set (making the template parameter list invalid) and $\overline{T}\{0,|\overline{T}|\}\equiv{\overline{T}\{|\overline{T}|\}}\equiv{\overline{T}\{\}}$, we can exploit the pattern annotator for an interesting rewrite of at least one of the partial specializations defined before, e.g. of {\textit{at\_pos}}:
\begin{minted}{c++}
template<std::size_t N, typename... T{}[N < sizeof...(T)]>
struct at_pos<N,typevector<T...>>
{ typedef T{N} type; };
\end{minted}
\end{enumerate}
\subsection{Combining with different kinds of expansions}
\p An interesting consequence of \textit{full interval annotation} in function templates derives from the fact that although interval annotation refers to a set of instantiations for which said template is to provide a valid match, it is one instantiation at a time actually occuring that is constrained to be matched with said template.
According to the annotation rules, an \textit{anchored expansion} whose enclosed constant expression does not fall within the specified expansion interval gets removed from the candidate match set.

\p However, at instantiation time there is a specific, non-alterable length to which the expansion is to occur. Therefore multiple well-formed anchored expansions in function calls can be used in combination with a no-op (e.g. \textbf{void gun(...)\{\}}, notice the use of the ellipsis) to make the following function template definition provide the optimal locality of reference for a series of different expansion semantics depending on the length of the parameter list used.
The following snippet is taken from a GoingNative 2012 talk\cite{Alexandrescu2012} by Andrei Alexandrescu, to which annotation is bolted on for illustrative purposes.
\begin{minted}{c++}
template<class...{4,7} Ts>        /* sizeof...(Ts)= 4, 5 or 6 during instantiation ! */
void fun(Ts... vs) {              /* we do not specify an anchored expansion yet */
    gun(A<Ts...{4}>::hun(vs)...); /* sizeof...(Ts) = 4, else no-op */
    gun(A<Ts...{5}>::hun(vs...)); /* sizeof...(Ts) = 5, else no-op */
    gun(A<Ts>::hun(vs)...{6});    /* sizeof...(Ts) = 6, else no-op */
}
\end{minted}
\p While the same effect could be achieved through extensive use of SFINAE and/or tag dispatching, it would require a lot more boilerplate and direct intervention into the function signatures of some of the function templates involved (e.g. \textbf{gun}).
Annotation has the advantage of leaving the constant expressions within annotators to either be explicitly specified or evaluated during instantiation based on even more complex constraints.
\subsection{The C++11/C++14 block switch effect, better}
\p Using function templates and lambdas, a peculiar kind of "switch" may be implemented in {\color{red}{\textbf\textit{valid}}} C++11 / C++14 as in the following code snippet.
Specifically, lambdas and SFINAE are combined to provide a "block switch" effect within the body of the \textit{func\_templ} function template depending on the number of parameters present in the pack during instantiation.
The \textit{no-op} calls are optimized away.
\begin{minted}{c++}
template<std::size_t N, typename... X, typename F>
typename std::enable_if<(sizeof...(X) == N),void>::type sel(F&& f) { f(); }

template<std::size_t N, typename... X>
void sel(...) {} /* no-op */

template<typename... T>
typename std::enable_if<(sizeof...(T) >= 1) && (sizeof...(T) < 6),void>::type
function(T... t) {
    sel<1,T...>([&t...](){ printf("one\n"); });
    sel<2,T...>([&t...](){ printf("two\n"); });
    sel<3,T...>([&t...](){ printf("three\n"); });
    sel<4,T...>([&t...](){ printf("four\n"); });
    sel<5,T...>([&t...](){ printf("five\n"); });
}
\end{minted}

\p We can implement the previous example more easily with interval annotation.
An invalid anchored pack expansion for a pack identifier declared with interval annotation removes the template from the resolution candidates.
Thus, it becomes easier to use such idioms even without the \textit{std::enable\_if} C++11/C++14 template when defining the \textit{func\_tmpl} function template and its assistive functions.

\begin{minted}{c++}
template<typename...X, typename F>
void sel(F&& f) { f(); }

void sel(...) {} /* no-op */

template<typename... T{1,6}>
void func_tmpl(T... t) {
    sel<T...{1}>([&t...](){ printf("one\n"); });
    sel<T...{2}>([&t...](){ printf("two\n"); });
    sel<T...{3}>([&t...](){ printf("three\n"); });
    sel<T...{4}>([&t...](){ printf("four\n"); });
    sel<T...{5}>([&t...](){ printf("five\n"); });
}
\end{minted}


\subsection{Enhancing class template partial specializations}
\p In contrast to function templates, the ability of class templates to have partial specializations makes them more malleable to specifying patterned sequences of types upon which template meta-programming driven type pattern matching occurs.
A naive implementation for specializing a class template definition according to the size of the parameter pack declared in the template parameter list would require as many partial specializations as the sizes of interest.

\p The following is a non-naive {\color{red}{\textbf\textit{valid}}} C++11 / C++14 implementation where the partial specializations required for this kind of problem are delegated to a nested class template.
The partial specializations of the nested template are subject to removal from the resolution set through \textit{std::enable\_if}.
Unlike the approach we followed in function templates, partial specializations open the door for more complex type calculations for "block-switch" like problems.
\begin{minted}{c++}
template<typename... X>
struct classy_impl {
private:
    struct void_{};
    
    template<bool B, typename Z> /* C++14 has this as std::enable_if_t */
    using enabler = typename std::enable_if<B,Z>::type;
    
    template<typename, typename...> struct impl_{};
    
    template<typename... T>
    struct impl_<enabler<(sizeof...(T) >= 0 && sizeof...(T) < 3), void_>, T...>
    { static void deploy(){ printf("[0,3)\n"); } };
    
    template<typename... T>
    struct impl_<enabler<(sizeof...(T) >= 3 && sizeof...(T) < 6), void_>, T...>
    { static void deploy(){ printf("[3,6)\n"); } };
    
    template<typename... T>
    struct impl_<enabler<(sizeof...(T) >= 6), void_>, T...>
    { static void deploy(){ printf(">=6\n"); } };
public:
    typedef impl_<void_,X...> type;
};

template<typename... X>
using classy = typename classy_impl<X...>::type;
\end{minted}
\p If we try to solve the same problem using \textit{interval annotation}, there is not even need for a nested template to exist in order to handle the necessary partial specializations.
The inherent SFINAE character of annotation semantics allows for a very succint formulation of programmer intent directly into C++ code.
Additionally, there is no need to provide for a long series of specializations even in naive implementations, making constructs depending on pattern matching through long sets of partial specializations easier to deal with.
\begin{minted}{c++}
template<typename...>
struct classy {
    static void deploy()
    { printf("sizeof...(X) >=6\n"); }
};

template<typename... X{0,3}>
struct classy<X...> {
    static void deploy()
    { printf("sizeof...(X) in [0,3)\n"); }
};

template<typename... X{3,6}>
struct classy<X...> {
    static void deploy()
    { printf("sizeof...(X) in [3,6)\n"); }
};
\end{minted}
\section{Currently undebated sections and other lacunae}
\p {\color{tone1}{There needs to be a section on the pattern annotator itself.
The expansion semantics under annotation are distributed throughout the text and should be concentrated in a separate section and discussed explicitly.
The introductory section needs some work after the newer additions.
The pattern matching examples for template meta-programming constructs in currently valid C++ need to be given their own example set.
Technical specification in a format compatible to the standard is currently missing.}}

\section{Technical specification}
\subsection{Grammar Additions}
\p{\color{tone0} This section will be among the last ones to be added because it requires far more constrained yet precise wording as to what would need to be amended in the C++ standard for annotators to be used.}
\section{Acknowledgements}
The author would like to thank Ville Voutilainen, current C++ Standard Commitee EWG Chairman for strongly motivating the drafting of this document.
The "fixed size parameter packs" notion was originally discussed and presented on the C++ std-proposals mailing\cite{Bos2014} list on a thread started by Maurice Bos.

\addcontentsline{toc}{section}{References}
\printbibliography
\end{document}