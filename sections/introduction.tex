%%% 
%%% Annotated C++ template parameter packs
%%% 
%%% Copyright (C) 2014, George Makrydakis irrequietus@gmail.com>
%%%
%%% This document is released under a Creative Commons 4.0 license, specifically
%%% Attribution-NonCommercial-NoDerivatives 4.0 International. Details for the
%%% aforementioned license at http://creativecommons.org/licenses/by-nc-nd/4.0/
%%% This repository's "license.txt" contains the full text of said license.
%%%
%%% This document draft discusses the possibility of extending C++ template
%%% parameter packs with optional syntax described as "annotation". The only
%%% git repository for tracking real-time changes by the original author is
%%% at https://github.com/irrequietus/atpp.
%%%
%%% Periodically, the author ships major/important revisions of the draft in
%%% PDF format, using the project website at http://atpp.irrequietus.eu with
%%% each PDF file having a specific sha1sum checksum.
%%%
%%% This section is part of said document.

\subsection{How to read this document}

\p If you are interested in quick examples of the syntax itself, focus on introduction, parameter pack annotation semantics and deployment scenarios.
The sections alluding to "formal" proofs of the equivalent forms will be completed and moved to an addendum to the paper in its final N-numbered form.
Ternary annotation refers to the generative aspects of annotation itself and is being currently prepared.
The interplay between concepts \cite{Stroustrup2012,Sutton2013} and how pack annotation works \textit{with} them, enhancing \textit{them} without \textit{them} being able to supplant annotation (and any other kind of pack processing proposal related to EWG issue 30 \cite{Abrahams2012} like this one) is being formally processed (boring to read) and will be merged later on.
The goal is to produce a very compact proposal document with an addendum related to details beyond code sample exposition.
Paragraphs on addressing several concerns are still being added so watch the official git repository of the document and its issue tracker.

\subsection{Making parameter packs first class citizens in a template parameter list}

\p Template parameter packs are product types, n-tuples of parameters of the same parameter type.
In all levels of C++ template meta-programming, recursive template instantiations can be shown to play the role of algebraic values, used in cohort with class template partial specializations, function template overloads, SFINAE, ADL, partial ordering, as template parameter list processing and type-safe code generation tools \cite{Munoz2008,JarviWL03,Abrahams2004,Alexandrescu2001}.
Such techniques are critical to fully exploiting C++ template meta-programming \textit{pattern matching} characteristics typically belonging to functional programming languages.

\p While parameter packs greatly enhance the functional nature of C++ template meta-programming \cite{Alexandrescu2012}, the lack of language level pack processing sfeatures related to both access and generation has been partially been addressed through template meta-programming library facilities out of which variadics had originally emerged as a proposal \cite{Czarnecki2000,Alexandrescu2001,Abrahams2004,Gregor2006,Gregor2008,Gregor2008a}.
When more complex constructs depending on parameter pack processing features became the norm in C++ libraries of widespread use, the limitations of the library approach became quite evident.

\p Of note, recourse to classical techniques in such libraries, as the aforementioned recursive template instantiations, proved onerous enough to stem C++ EWG issues and proposals at a language feature level \cite{Abrahams2012,Middleditch2013,Wakely2013,Wakely2013a} that aim to \textit{greatly enhance template meta-programming itself}; such bibliography offers ample motivation and examples of interest to the reader, making library-level reccomendations for such features confusing and fears of increasing complexity of template meta-programming objectively unfounded.
Importantly, they may even ease the implementation of purely functional programming constructs for template meta-programming like \textit{monads} \cite{Porkolab2010,Sinkovich2013} for purposes including better error reporting \cite{Sinkovich2013}.

\p The \textit{actual} effect of adopting pack processing features at a language level is to turn constructs like \textit{typelists} \cite{Czarnecki2000,Alexandrescu2001,Abrahams2004} into first class citizens within template parameter lists.
In combination with \textit{concepts} \cite{Stroustrup2012,Sutton2013} (constraints that do not overlap with the actual intention of annotation), such features can almost totally eliminate the need for laborious source code boilerplate in vertical and horizontal dimensions, where even preprocessor meta-programming seems at times inevitable.

\p Future revisions of this draft will display similar effects of the same \textit{pack annotation} semantics for non-type and template-type template parameters and their interaction with concepts \cite{Stroustrup2012,Sutton2013}.
\newpage
\input{sections/syntaxtable.tex}
