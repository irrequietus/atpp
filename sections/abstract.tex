%%% 
%%% Annotated C++ template parameter packs
%%% 
%%% Copyright (C) 2014, George Makrydakis irrequietus@gmail.com>
%%%
%%% This document is released under a Creative Commons 4.0 license, specifically
%%% Attribution-NonCommercial-NoDerivatives 4.0 International. Details for the
%%% aforementioned license at http://creativecommons.org/licenses/by-nc-nd/4.0/
%%% This repository's "license.txt" contains the full text of said license.
%%%
%%% This document draft discusses the possibility of extending C++ template
%%% parameter packs with optional syntax described as "annotation". The only
%%% git repository for tracking real-time changes by the original author is
%%% at https://github.com/irrequietus/atpp.
%%%
%%% Periodically, the author ships major/important revisions of the draft in
%%% PDF format, using the project website at http://atpp.irrequietus.eu with
%%% each PDF file having a specific sha1sum checksum.
%%%
%%% This section is part of said document.

\p Parametric polymorphism in C++ is implemented through class and function templates whose template parameter lists are comprised of three different parameter types: template non-type, template type-type and template template-type parameters.
Template parameter \textit{packs} in C++11 \cite{cpp11} allow the declaration and use of n-ordered sequences of pararameters of the same parameter type within a template parameter list.
However, this is done without being able to directly specify pack size within a given range and/or pattern constraints, without having indexed or ranged access and with no ability to generate specific patterns through expansion through language features.

\p Library alternatives for pack processing are comprised of complex source code boilerplate in vertical (e.g. several function template overloads and class template partial specializations) and horizontal dimensions (e.g. overly complex SFINAE \cite{sfinae,JarviWL03}, extremely deep recursive instantiations), where even the type-unsafe assistance of preprocessor meta-programming may be required.
Reducing the need for such techniques by introducing language level parameter pack manipulation would not only make template meta-programming more approachable to novices, but also less cumbersome for experts.

\p Annotation semantics can specify pack sizes of either determined size or within a given range, reflect on whether a pack is comprised of a specific repeated pattern, easily offer patterned generation in expansion as well as indexed and ranged access while making implementation of functional programming constructs easier in template meta-programs.
