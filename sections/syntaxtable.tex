
\subsection{The rules and syntax of annotation}
\textcolor{RoyalBlue}{\textit{NB: This should substitute "Pack annotation semantics"; it should also become even shorter and it must be thoroughly checked that the semantics remain the same.}}

\p The following syntax lookup tables concentrate on annotator syntax and its significance in the context of the declaration and expansion of a parameter pack.
\textcolor{Magenta}{Magenta} colored elements are positive integral constant expressions.
The letter $T$ is used as a pack identifier, alluding to a sequence of parameter types of the same type (non-type template parameters, type-type template parameters, template-type template parameters) and annotators serve as size constraints in declaration and expansion, while providing access by index or range to the parameters contained in a pack.
\begin{enumerate}
\item\p The \textit{interval} annotator contains none, one or two comma separated positive integral constant expressions.
When no expression is specified, $sizeof...(T)$ is implied as an equivalent.
If and only if it is not followed by the \textit{pattern} annotator and $sizeof...(T)$ is implied, it may be omitted since it represents a form equivalent to a non-annotated template parameter pack.
In declaration with a single positive integral constant expression, a match is provided for a pack whose $sizeof...(T)$ is identical to said expression; with two, a match is provided for any compatible parameter sequence whose size is within the specified interval.
In expansion with a single positive integral constant expression, it expands the parameter pack it accompanies to a size equal to said expresion beginning from the leftmost parameter contained;
when used with two, it provides a valid match for any compatible parameter sequence of size within the specified interval.

\item\p The \textit{pattern} annotator can contain none or one positive integral constant expressions.
When no expression is specified, $\bm{1}$ is implied and it may be omitted since it represents a form equivalent to an \textit{interval}-annotated pack.
In declaration, the pattern annotator requires the pack it is applied upon to be an exact multiple of an ordered sequence of types, the latter of size equal to the integral constant expression it encloses. In expansion, it repeats the annotated pack as many times as said expression.
The \textit{pattern} annotator is a valid construct if and only if preceded by a valid \textit{interval} annotator.

\item\p The \textit{access} annotator is a degenerate form of the \textit{interval} annotator that can follow a pack identifier in only in substitution of the \textit{triple-dot} operator, with a single and mandatory integral constant expression; the construct has the effect of individually accessing a parameter within a pack at an index equal to said integral constant expression.
\end{enumerate}

\textcolor{RoyalBlue}{\textit{NB: This must be checked for typos and eventual omissions.}}

\begin{tabularx}{\textwidth}{l|c|X}
  \textbf{Syntactical Example} & \textbf{Use}  &\textbf{Significance} \\
\hline
$\bm{...T\{\textcolor{Magenta}{\textcolor{Magenta}{N}},\textcolor{Magenta}{M}\}[\textcolor{Magenta}{K}]}$ & D & $sizeof...(T) \in [\textcolor{Magenta}{N},\textcolor{Magenta}{M}) \wedge{} sizeof...(T) \% \textcolor{Magenta}{K} == \textcolor{Magenta}{0}$ \\
$\bm{...T\{\textcolor{Magenta}{N}\}[\textcolor{Magenta}{K}]}$ & D & $sizeof...(T) == \textcolor{Magenta}{N} \wedge{} \textcolor{Magenta}{N} \% \textcolor{Magenta}{K} == \textcolor{Magenta}{0}$ \\
$\bm{...T\{\}[\textcolor{Magenta}{K}]}$ & D & $sizeof...(T) \% \textcolor{Magenta}{K} == \textcolor{Magenta}{0}$ \\
$\bm{...T\{\textcolor{Magenta}{N}\}[\textcolor{Magenta}{1}]}$ & D & $sizeof...(T) == \textcolor{Magenta}{N}$ \\
$\bm{...T\{\}[\textcolor{Magenta}{1}]}$ & D & $...T$ \\
$\bm{...T\{\}[]}$ & D & $...T$ \\
$\bm{...T\{\}}$ & D &$...T$ \\
$\bm{...T\{\textcolor{Magenta}{sizeof...(T)}\}[\textcolor{Magenta}{1}]}$ & D & $...T$ \\
$\bm{...T\{\textcolor{Magenta}{sizeof...(T)}\}[]}$ & D &  $...T$ \\
$\bm{...T\{\textcolor{Magenta}{sizeof...(T)}\}}$ & D & $...T$ \\
$\bm{...T}$ & D & $...T$ \\
\end{tabularx}

\textcolor{RoyalBlue}{\textit{NB: This must be checked for typos and eventual omissions.}}

\begin{tabularx}{\textwidth}{l|c|X}
  \textbf{Syntactical Example} & \textbf{Use}  &\textbf{Significance} \\
\hline
$\bm{T\{\textcolor{Magenta}{N}\}}$ & E & access type by index $\textcolor{Magenta}{N}$ in $T$ \\
$\bm{T...\{\textcolor{Magenta}{N},\textcolor{Magenta}{M}\}[\textcolor{Magenta}{K}]}$ & E & $sizeof...(T)\geq{\textcolor{Magenta}{M}}$, as $\textcolor{Magenta}{K}$ times $ T\{\textcolor{Magenta}{N}\},T\{\textcolor{Magenta}{N+1}\},T\{\textcolor{Magenta}{N+2}\},...,T\{\textcolor{Magenta}{M-1}\}$ \\
$\bm{T...\{\textcolor{Magenta}{N}\}[\textcolor{Magenta}{K}]}$ & E & $sizeof...(T)\geq{\textcolor{Magenta}{N}}$, as $\textcolor{Magenta}{K}$ times $T\{\textcolor{Magenta}{0}\},T\{\textcolor{Magenta}{1}\},T\{\textcolor{Magenta}{2}\},...,T\{\textcolor{Magenta}{sizeof...(T)-1}\}$ \\
$\bm{T...\{\textcolor{Magenta}{N}\}[\textcolor{Magenta}{1}]}$ & E & $sizeof...(T)\geq{\textcolor{Magenta}{N}}$, as $T\{\textcolor{Magenta}{0}\},T\{\textcolor{Magenta}{1}\},T\{\textcolor{Magenta}{2}\},...,T\{\textcolor{Magenta}{sizeof...(T)-1}\}$ \\
$\bm{T...\{\textcolor{Magenta}{N}\}[]}$ & E & $sizeof...(T)\geq{\textcolor{Magenta}{N}}$, as $T\{,\textcolor{Magenta}{0}\},T\{,\textcolor{Magenta}{1}\},T\{,\textcolor{Magenta}{2}\},...,T\{\textcolor{Magenta}{N}-1\}$ \\
$\bm{T...\{\}[\textcolor{Magenta}{K}]}$ & E & as $\textcolor{Magenta}{K}$ times $T\{\textcolor{Magenta}{0}\},T\{\textcolor{Magenta}{1}\},T\{\textcolor{Magenta}{2}\},...,T\{\textcolor{Magenta}{sizeof...(T)-1}\}$ \\
$\bm{T...\{\textcolor{Magenta}{sizeof...(T)}\}[\textcolor{Magenta}{K}]}$ & E & as $\textcolor{Magenta}{K}$ times $T\{\textcolor{Magenta}{0}\},T\{\textcolor{Magenta}{1}\},T\{\textcolor{Magenta}{2}\},...,T\{\textcolor{Magenta}{sizeof...(T)-1}\}$ \\
$\bm{T...\{\}[\textcolor{Magenta}{1}]}$ & E & $T...$ \\
$\bm{T...\{\}[]}$ & E & $T...$ \\
$\bm{T...\{\}}$ & E & $T...$\\
$\bm{T...\{\textcolor{Magenta}{sizeof...(T)}\}[\textcolor{Magenta}{1}]}$ & E & $T...$ \\
$\bm{T...\{\textcolor{Magenta}{sizeof...(T)}\}[]}$ & E & $T...$ \\
$\bm{T...\{\textcolor{Magenta}{sizeof...(T)}\}}$ & E & $T...$\\
$\bm{T...}$ & E & $T...$\\
\end{tabularx}

\p Annotators thus allow index and interval-based parameter pack semantics to be used in both declaration (for matching purposes) and expansion (for matching and generative purposes) and address directly \textbf{EWG\#30} \cite{Abrahams2012} using terse, unambiguous and coherent syntax that graciously degenerates into parameter packs as we know them today.
This is by design so that they can be easily submitted to \textit{partial ordering}, a well known matching criterion in C++ between them and regular parameter packs.
Any annotation where an invalid interval is specified, removes the template containing such pack from the matching candidates status, which is the SFINAE \cite{sfinae} effect in this case.

\subsection{Ternary Annotation and Generative Constructs}
    \input{sections/ternary_annotation_generative.tex}
        
